#!/usr/bin/env python3

import argparse
import csv
import dateutil.parser
import dateutil.tz
import logging

from datetime import datetime, tzinfo
from dataclasses import dataclass

import pytz

from icalendar import Calendar, Event


@dataclass
class Activity:
    start_time: datetime
    stop_time: datetime
    timezone: tzinfo
    name: str

    def emojified_name(self) -> str:
        emoji = ""
        if self.name == "Basketball":
            emoji = "ðŸ€"
        elif self.name == "Cycling":
            emoji = "ðŸš´"
        elif self.name == "Gym class":
            emoji = "ðŸ’ª"
        elif self.name == "Hiking":
            emoji = "ðŸ¥¾"
        elif self.name == "Indoor Cycling":
            emoji = "ðŸš´"
        elif self.name == "Multi Sport":
            emoji = "ðŸ’ª"
        elif self.name == "Other":
            emoji = "ðŸ’ª"
        elif self.name == "Rowing":
            emoji = "ðŸš£â€â™‚ï¸"
        elif self.name == "Running":
            emoji = "ðŸƒ"
        elif self.name == "Swimming":
            emoji = "ðŸŠ"
        elif self.name == "Tennis":
            emoji = "ðŸŽ¾"
        elif self.name == "Walking":
            emoji = "ðŸš¶"
        elif self.name == "Weights":
            emoji = "ðŸ‹ï¸"
        elif self.name == "Yoga":
            emoji = "ðŸ§˜"

        return f"{emoji} {self.name}" if emoji else self.name


def generate_ics(activities: list[Activity], output_file: str, emojis: bool) -> None:
    calendar = Calendar()
    for activity in activities:
        event = Event()
        event.add("summary", activity.emojified_name() if emojis else activity.name)
        event.add("dtstart", activity.start_time)
        event.add("dtend", activity.stop_time)
        event.add("X-DT-DATEUTIL", activity.timezone)
        calendar.add_component(event)

    with open(output_file, "wb") as file:
        file.write(calendar.to_ical())


def main(args: argparse.Namespace) -> None:
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    last_activity = (
        parse_ics_last_event(args.last_ics_file) if args.last_ics_file else None
    )

    activities = parse_csv_activities(args.activities_csv_file, last_activity)
    generate_ics(activities, args.output_ics_file, args.emojis)
    logging.info("ICS file generated at %s", args.output_ics_file)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Parse CSV data exported by the Withings Health Mate app and generate an "
            "ICS file."
        )
    )

    parser.add_argument(
        "-e",
        "--emojis",
        action="store_true",
        help="Prepend emojis to calendar event names."
    )
    parser.add_argument(
        "-i",
        "--activities-csv-file",
        required=True,
        help="Path to the activities CSV file.",
    )
    parser.add_argument(
        "-l",
        "--last-ics-file",
        help="Path to the last ICS file generated by this script.",
    )
    parser.add_argument(
        "-o", "--output-ics-file", required=True, help="Path to the output ICS file."
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Print verbose logging  output."
    )

    return parser.parse_args()


def parse_csv_activities(
    csv_file: str, last_activity: Activity | None
) -> list[Activity]:
    activities = []

    with open(csv_file, "r", newline="") as file:
        reader = csv.reader(file)
        next(reader)  # Skip header
        for row in reader:
            timezone = pytz.timezone(row[4])
            start_time = dateutil.parser.isoparse(row[0]).replace(tzinfo=timezone)
            stop_time = dateutil.parser.isoparse(row[1]).replace(tzinfo=timezone)
            name = row[5]

            # If we don't have a last activity (because this is the first time the script
            # is being run, for instance), then always add the activity. Otherwise, add
            # the activity only if it is more recent than the date of the last activity.
            should_add_activity = (
                not last_activity or start_time > last_activity.stop_time
            )

            if should_add_activity:
                logging.debug(
                    "Adding activity %s at %s -> %s (%s)",
                    name,
                    start_time,
                    stop_time,
                    timezone,
                )
                activities.append(
                    Activity(
                        start_time=start_time,
                        stop_time=stop_time,
                        timezone=timezone,
                        name=name,
                    )
                )

    return activities


def parse_ics_last_event(ics_file: str) -> Activity | None:
    logging.info("Finding last event from ICS file %s", ics_file)
    with open(ics_file, "r") as file:
        calendar = Calendar.from_ical(file.read())
        events = list(calendar.walk("vevent"))
        if not events:
            return None
        last_event = events[-1]
        start_time = last_event.get("dtstart").dt
        stop_time = last_event.get("dtend").dt
        timezone = start_time.tzinfo.zone if start_time.tzinfo else pytz.UTC
        name = str(last_event.get("summary"))
        return Activity(
            start_time=start_time, stop_time=stop_time, timezone=timezone, name=name
        )


if __name__ == "__main__":
    main(parse_args())
